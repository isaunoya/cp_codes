## A.

模拟。

## B.

考虑到只有 $a_i \geq a_{i-1}$ 才会塞数字，当 $a_{i} \geq a_{i - 1}$ 的时候直接塞，否则连塞两个。

## C.

差分后前缀和。

## D.

二分答案，找到最大的 $x \times (x - 1) \leq 2 \times n$，然后答案就是 $x + n - \frac{x \times (x - 1)}{2}$。

## E.

发现答案是 $[1, i]$ 选最大的 $m$ 个，然后减掉 $d \times i$，用堆贪心维护即可。

## F.

背包。

## G.

考虑怎么样才会变成答案，首先不难想到，有一个简单的 $O(n^2)$ 算法，因为每次操作相邻的会差分减一。所以我们选择操作 $\min{a_i - a_{i-1}}$ 次，这样稳定消掉一个，就可以做到 $O(n^2)$，发现每次都是相邻的合并，所以最大值一定会一直留着（可能会被合并，但是没有关系）。

所以是 $\max +$ 操作次数。

考虑操作次数要怎么求，具体的，每次选差分最小值，整体再减掉最小值，重复这个过程，**容易**知道总操作次数为 $\max a_i - a_{i-1}$，所以是可以动态维护这个东西的。